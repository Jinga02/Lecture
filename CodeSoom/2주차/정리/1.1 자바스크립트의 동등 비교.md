리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 그리고 이 props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.
리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.
자바스크립트의 이러한 동등비교는 어떻게 수행되는지, 또 이를 리액트에서 어떻게 활용하고 있는지 살표보자.

1. **자바스크립트의 데이터 타입**

- 원시타입
  1. boolean
  - 참(ture)와 거짓(false)만을 가질 수 있는 데이터 타입
  - true, false와 같은 boolean 형의 값 외에도 조건문에서 마치 true와 false처럼 취급되는 truthy, falsy 값이 존대한다.
  2. null
  3. undefined
  4. string
  5. number
  6. symbol
  7. bigint
- 객체타입
  1. object

2. **값을 저장하는 방식의 차이**

   원시타입과 객체타입의 가장 큰 차이점은, 바로 값을 저장하는 방식의 차이이다. 이 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이 된다.

- 원시타입

  - 불변 형태의 값으로 저장된다.
  - 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.
  - 값을 복사해 전달한다.

- 객체 타입
  - 객체는 프로퍼티를 추가, 삭제, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장된다.
  - 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.
  - 즉, 값은 같을지언정 참조하는 곳은 다르다.

3. **또 다른 비교 공식, Object.is**

   Object.is는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다.

   - == 나 ===와 다른 점
     1. == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 변경한다. 하지만 Object.is는 이러한 작업을 하지 않는다.
     2. NaN의 처리: NaN === NaN은 false를 반환하지만, Object.is(NaN, NaN)은 true를 반환합니다. 즉, Object.is는 NaN 값을 서로 같다고 간주한다. 1
     3. 부호 있는 0의 처리: 0 === -0은 true를 반환하지만, Object.is(0, -0)은 false를 반환합니다. 이는 Object.is가 +0과 -0을 구별한다는 것을 의미한다.

4. **리액트에서의 동등 비교**

   - 리액트에서 사용하는 동등 비교는 Object.is다
   - Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 [얕은 비교](https://dori-coding.tistory.com/entry/React-%EC%96%95%EC%9D%80-%EB%B9%84%EA%B5%90%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B9%84%EA%B5%90%EC%9D%98-%EC%B0%A8%EC%9D%B4)를 한 번 더 수행한다.
   - 리액트에서 컴포넌트의 렌더링은 주로 props의 변화에 따라 결정된다. 그러나 props로 새로운 객체를 전달할 경우, 객체의 참조 값이 달라지기 때문에 리액트는 이를 새로운 props로 인식하고 불필요한 렌더링을 발생시킬 수 있다.
   - props가 깊어지는 경우, 즉 한 객체 안에 또다른 객체가 있을 경우 React.memo는 컴포넌트에서 실제로 변경된 값이 없으에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다.

**정리**
