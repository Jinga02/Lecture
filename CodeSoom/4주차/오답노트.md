1. 함수형 컴포넌트가 매번 실행되더라도 useState가 이전의 값을 정확하게 꺼내 쓸 수 있는 이유는 무엇인가요?
   책에 있음
2. useEffect의 클린업 함수와 생명주기 메서드의 언마운트 개념과 차이는 무엇인가요?
   언마운트는 컴포넌트가 없어질 때, 클린업 함수는 이전의 내용(부수 효과)을 초기화할 때 쓴다
   useEffect의 클린업 함수는 언마운트될때 만 호출되는 것이 아니다. 렌더링이 일어날 떄 마다 호출되고 의존성이 변경될 때마다 호출된다
   클린업 함수는 이전의 내용을 초기화할 때 쓴다
3. 다음 두 가지 코드의 실행 차이는 무엇인가요?

4. 다음 코드의 위험성은 무엇인가요?
   race condition때문에
   fetchInfo (10초) setInfo -> 렌더링
   id -> 바뀜
   fetchInfo(1초)
   setInfo() -> 렌더링
5. 다음과 같이 사용하지 않고 useRef를 써야만 하는 이유는 무엇인가요?
   컴포넌트를 여러번 호출할 때 마다 동일한 값을 바라봐서 안된다
   이 value를 컴포넌트 안으로 옮기면 계속 같은 값으로 초기화 되니까 useRef를 써야한다.

```js
function Component() {
  let value = 1;
}
const data = {
  setData(value) {
    data.value = value;
    data.render((it) => it + 1);
  },
};
function Component() {
  const [, setState] = useState(0);

  data.render = setState;

  return <div></div>;
}
```

6. useContext가 상태 관리를 위한 API가 아닌 이유는 무엇인가요?
   책에 있음
7. useEffect 대신에 useLayoutEffect를 대신 사용해야 하는 상황은 어떤 상황인가요?
8. 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까요?
9. SPA가 인기를 끌었던 이유는 무엇인가요?
   책에 있음
10. 서버 사이드 렌더링이 다시 인기를 끌게된 이유는 무엇인가요?
    책에 있음
11. 서버 사이드 렌더링의 장점과 단점에 대해서 설명해 주세요.
    책에 있음

번외
함수시그니처의 중요성 매우매우 중요함 추가로 공부하자
useEffect의 시그니처 비동기 작동?
타입 인터페이스는? -> 시그니처의 모음이다 -> 시그니처는 함수 이름 파라미터 반환타입

```

```
