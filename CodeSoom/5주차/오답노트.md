1. Next.js에서 페이지를 이동할 때 a태그 대신 Link를 사용하고 window.location.push 대신에 router.push를 사용해야 하는 이유는 무엇인가요?
   a 태그를 사용하면 다시 그리는데 Link를 사용하면 변경된 부분만 다시그린다.
   a 태그로 이동하면 SSR로 다시하고, 링크로 이동하면 CSR로 한다.

   윤석님 의견 :
   Next.js는 초기 로딩은 서버사이드 렌더링을 하고 그 다음 페이지 이동은 클라이언트 사이드 렌더링을 한다.
   왜 ? SSR의 장점과 SPA의 장점을 합쳤다!
   SPA 방식은 필요한 부분만 변경하여 효율적으로 동작하고
   서버 사이드 렌더링은 초기 로딩속도가 빠르기도 하고
   서버 사이드 렌더링은 검색 엔진 최적화를 위해서도 쓰인다.
   a태그를 사용하면 다시 그레는데 Link를 사용하면 변경된 부분만 다시그린다.
   a 태그로 이동하면 SSR로 다시하고, 링크로 이동하면 CSR로 한다.

   **정리한 답변**

   1. 성능 최적화: Link 컴포넌트를 사용하면 페이지 이동 시 변경된 부분만 다시 렌더링되어 성능이 향상된다. 이는 사용자 경험을 향상시키고 불필요한 리렌더링을 방지한다.

   2. 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)의 조합: Next.js는 초기 로딩을 서버 사이드 렌더링으로 처리하고, 이후의 페이지 이동은 클라이언트 사이드 라우팅으로 처리한다. 이는 SSR의 장점과 SPA의 장점을 결합하여 애플리케이션의 초기 로딩 속도를 높이고, 동적인 페이지 이동을 가능하게 한다.

   3. 검색 엔진 최적화(SEO): 서버 사이드 렌더링은 검색 엔진 최적화를 위해 중요하다. Link 컴포넌트를 사용하면 페이지 이동 시 클라이언트 사이드에서만 처리되지 않고 서버 사이드에서도 처리되므로, 검색 엔진이 페이지를 색인하기 쉽다.

   이에 따라, Link 컴포넌트와 router.push를 사용하여 페이지 이동을 관리하는 것이 성능과 검색 엔진 최적화를 고려한 최적의 방법이다!!!

2. 상태 관리는 왜 필요할까요?
   상태 관리와
   제어 흐름
   상태 관리가 걍 어렵다
   왜 어렵냐
   특정 상태가 되었을 때 왜 이런 상태인지 알기 어렵다

   **정리한 답변**

   상태 관리의 필요성은 복잡한 애플리케이션을 개발하고 유지보수하는 과정에서 나타난다.

   1. 상태 관리와 제어 흐름

   애플리케이션은 사용자와 상호작용하면서 상태가 변화한다. 이러한 상태의 변화를 관리하기 위해서는 제어 흐름을 명확하게 해야 한다. 즉, 어떤 상태가 어떤 조건에 의해 변화하는지를 정확히 파악하고, 이를 제어하는 것이 필요하다. 상태 관리는 이러한 제어 흐름을 효율적으로 관리하는 것을 의미한다.

   2. 상태 관리의 어려움

   상태관리가 어려운 이유 중 하나는 특정 상태가 어떤 조건 또는 상황에 의해 변경되었는지 이해하기 어렵기 때문
   특히 복잡한 애플리케이션에서는 여러 컴포넌트 간의 상태 공유 및 상태 변화 추적이 복잡해질 수 있다. 이로 인해 코드의 가독성과 유지 보수성이 떨어질 수 있다.

   3. 상태가 왜 그렇게 변하는지 이해하기 어려움

   특정 상태가 특정 조건에 의해 변화하는 이유를 이해하는 것은 상태 관리에서 중요한 부분이다. 상태가 변할 때마다 그 변화가 어떤 행동이나 조건에 의해 발생하는지를 파악함으로써, 코드를 더 예측 가능하고 이해하기 쉽게 만들 수 있다.

   따라서, 상태 관리는 복잡한 애플리케이션에서 제어 흐름을 명확하게 하고, 상태의 변화를 추적하고 이해하기 쉽게 하는 중요한 개념이다. 이를 통해 코드의 가독성과 유지 보수성을 높이고, 개발자들이 애플리케이션의 동작을 더 잘 이해하고 제어할 수 있게 된다.

3. Flux패턴이란 무엇이고 왜 사용해야 할까요?
   액션과 타입을 디스패처로 스토어로 보내고
   스토어를 구독하고 있어서 캐치해서 UI에 반영한다
   상태를 변경하는 것을 단방향으로 한다.
   문이 하나다
   윤석님 의견:
   단방향이라고 개쩔고 좋나? 엄청난가? 그건 또 아니다
   그냥 양방향 자체가 그냥 복잡하다
   왜냐하면 모순을 만들어낸다
   프론트말고 백엔드에서도 데이터흐름을 단방향으로 만들기 위해 설계를 한다!

   **정리한 답변**

   1. 단순성: 단방향 데이터 흐름을 통해 코드의 복잡성을 줄이고, 데이터의 흐름을 이해하기 쉽게 만든다.
   2. 유지 보수성: 단일한 상태 저장소와 단방향 데이터 흐름은 코드의 예측 가능성을 높이고, 디버깅 및 유지 보수를 용이하게 한다.
   3. 확장성: Flux 패턴은 컴포넌트 간의 의존성을 최소화하고, 독립적으로 확장 가능한 애플리케이션을 구축하는 데 도움을 준다.

4. useState를 사용한 지역 상태의 한계는 무엇일까요?

   **정리한 답변**
   클로저를 통해 관리되서 지역 상태로 밖에..

   1. 컴포넌트 간 상태 공유의 어려움: useState를 사용하여 관리되는 상태는 해당 컴포넌트 내에서만 유지된다. 따라서, 다른 컴포넌트에서 동일한 상태에 접근하거나 상태를 공유하기 위해서는 상위 컴포넌트로 상태를 끌어올리거나 컴포넌트 간 통신을 위한 별도의 패턴이 필요하다.
   2. 복잡한 상태 관리의 어려움: 애플리케이션이 복잡해지고 상태가 복잡해질수록 useState만으로 상태를 관리하는 것이 어려워진다. 복잡한 상태 관리를 위해서는 상태를 조작하고 업데이트하는 로직을 여러 곳에 분산시키는 것이 필요할 수 있다.
   3. 성능 저하: 컴포넌트가 다시 렌더링될 때마다 useState로 관리되는 상태가 초기화되는 경우가 있다. 이는 성능 저하를 가져올 수 있다. 특히 컴포넌트의 렌더링이 빈번하게 발생하거나 상태가 많은 경우에는 이러한 초기화가 더 큰 문제가 될 수 있다.
   4. 상태 업데이트의 복잡성: useState를 사용하여 관리되는 상태는 불변성을 유지해야 하므로 상태를 업데이트하는 과정이 복잡해질 수 있다. 특히 복잡한 데이터 구조를 가진 상태의 경우에는 상태를 업데이트하는 과정이 번거로울 수 있다.

      이러한 한계로 인해 애플리케이션이 복잡해지고 상태 관리가 필요한 경우에는 상태 관리 라이브러리 또는 상태 관리 패턴을 사용하는 것이 더 적합할 수 있다. Redux, MobX, Recoil 등의 상태 관리 라이브러리를 활용하거나 Context API와 useReducer를 결합하여 상태를 관리하는 것이 일반적인 대안이다.

5. 어떤 기준으로 상태 관리 라이브러리를 고르는게 좋을까요?

6. 제어의 역전...
   프레임워크를 쓰는 이유
   제어의 역전을 위해..
   제어의 역전이란? 제어의 흐름을 강제하는것

오늘 한 상태관리의 발전 꼭 다시 하기!!!
